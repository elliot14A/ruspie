<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>docs</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../../index.html">Home</a></li><li class="chapter-item expanded "><a href="intro.html"><strong aria-hidden="true">1.</strong> Intro</a></li><li class="chapter-item expanded "><a href="quick_start.html"><strong aria-hidden="true">2.</strong> Quick Start Guide</a></li><li class="chapter-item expanded "><a href="configuration.html"><strong aria-hidden="true">3.</strong> Configuration</a></li><li class="chapter-item expanded "><a href="endpoints.html"><strong aria-hidden="true">4.</strong> Endpoints</a></li><li class="chapter-item expanded "><a href="quering.html"><strong aria-hidden="true">5.</strong> Querying</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rest.html"><strong aria-hidden="true">5.1.</strong> Rest</a></li><li class="chapter-item expanded "><a href="sql.html"><strong aria-hidden="true">5.2.</strong> Sql</a></li><li class="chapter-item expanded "><a href="graphQl.html"><strong aria-hidden="true">5.3.</strong> GraphQL</a></li></ol></li><li class="chapter-item expanded "><a href="authorization.html"><strong aria-hidden="true">6.</strong> Authorization</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">docs</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="ruspie"><a class="header" href="#ruspie">RUSPIE</a></h1>
<h2 id="introduction"><a class="header" href="#introduction">INTRODUCTION</a></h2>
<p>Ruspie is a query engine for datasets stored in CSV and Parquet formats. It allows you to query your data using SQL, REST API, and GraphQL. Ruspie is built on top of Apache Arrow and Datafusion, and it is written in Rust.</p>
<p>To use Ruspie, you can start the server by running the <code>cargo run</code> command, and specifying the path to your dataset files using the <code>FILE_PATH</code> environment variable. You can then send queries(SQL, GraphQL, REST Query params) to the server using the REST API. Ruspie supports a variety of query operators, such as filtering, sorting, and limiting the number of results, which can be specified in the query.</p>
<h2 id="quickstart"><a class="header" href="#quickstart">QUICKSTART</a></h2>
<p>To quickly setup Ruspie, follow these steps:</p>
<p>Install Rust, if you don't already have it installed. You can do this by following the instructions on the Rust website: https://www.rust-lang.org/tools/install.</p>
<p>Clone the Ruspie repository from GitHub: git clone https://github.com/factly/ruspie.git</p>
<p>Navigate to the cloned repository and build the project using <code>cargo build</code></p>
<p>Set the <code>FILE_PATH</code> environment variable to the path of the dataset files that you want to serve through the API. For example: <code>FILE_PATH=./data</code></p>
<p>Start the Ruspie server by running <code>cargo run</code></p>
<p>You can now send queries to the Ruspie server using the REST API, SQL, or GraphQL. For more information, see the documentation for the project.</p>
<p>Note: If you want to enable token-based authorization, you will need to set the <code>MASTER_KEY</code> environment variable before starting the server. This will enable authentication for all the endpoints, and you will need to pass a valid authorization token in the <code>AUTHORIZATION</code> header of your requests.</p>
<h2 id="configuration"><a class="header" href="#configuration">CONFIGURATION</a></h2>
<p>You can configure Ruspie using environment variables. The following environment variables are available:</p>
<p><code>FILE_PATH</code>: This specifies the path to the dataset files that you want to serve through the API. If not set, the default is the test directory in the root of the project.</p>
<p><code>PORT</code>: This specifies the port that the Ruspie server will listen on. If not set, the default is 8080.</p>
<p><code>MASTER_KEY</code>: This enables token-based authorization for all endpoints. If not set, authentication is disabled.</p>
<p><code>LIMIT</code>: This specifies the default limit on the number of results returned by a query. If not set, the default is 100.</p>
<p><code>MAX_LIMIT</code>: This specifies the maximum limit that can be specified in a query. If not set, the default is 1000.</p>
<p><code>DEFAULT_EXT</code>: This specifies the default file extension that Ruspie will look for when serving files through the API. If not set, the default is csv.</p>
<p>To set an environment variable, you can use the export command before starting the Ruspie server. For example, to set the FILE_PATH variable to the data directory and the PORT variable to 8080, you can run the following commands:</p>
<pre><code class="language-bash">export FILE_PATH=./data
export PORT=8080
cargo run
</code></pre>
<p>You can also set the environment variables in your shell configuration file (e.g. .bashrc or .zshrc) so that they are automatically set when you open a new terminal. For more information, see the documentation for your shell.</p>
<h2 id="endpoints"><a class="header" href="#endpoints">ENDPOINTS</a></h2>
<p>Ruspie exposes the following endpoints:</p>
<ol>
<li>
<p>GET /api/tables/{table_name}: This endpoint allows you to query a dataset using the REST API. You can specify query operators such as filters, sorting, and limits in the URL query parameters.</p>
</li>
<li>
<p>POST /api/sql: This endpoint allows you to query a dataset using SQL. You can pass the SQL query in the request body as plain text.</p>
</li>
<li>
<p>POST /api/graphql: This endpoint allows you to query a dataset using GraphQL. You can pass the GraphQL query in the request body as plain text.</p>
</li>
<li>
<p>GET /api/schemas/{table_name}: This endpoint returns the schema of the specified dataset.</p>
</li>
</ol>
<p>Note: If you have enabled token-based authorization, these endpoints will require a valid authorization token to be passed in the AUTHORIZATION header of the request.</p>
<p>Additionally, the following endpoints are available for managing API keys when token-based authorization is enabled:</p>
<ol>
<li>
<p>GET /auth/keys: This endpoint allows you to list all the API keys that have been generated.</p>
</li>
<li>
<p>POST /auth/keys: This endpoint allows you to generate a new API key.</p>
</li>
<li>
<p>PATCH /auth/keys/{key_id}: This endpoint allows you to update the name and description of an existing API key.</p>
</li>
<li>
<p>DELETE /auth/keys/{key_id}: This endpoint allows you to delete an existing API key.</p>
</li>
<li>
<p>POST /auth/keys/invalidate/{key_id}: This endpoint allows you to invalidate an existing API key, preventing it from being used to access the API.</p>
</li>
</ol>
<h2 id="querying"><a class="header" href="#querying">QUERYING</a></h2>
<h3 id="rest"><a class="header" href="#rest">REST</a></h3>
<p>To query a dataset using query parameters in Ruspie, you can send a <code>GET</code> request to the <code>/api/tables/{table_name}</code> endpoint, where <code>table_name</code> is the name of the dataset you want to query. You can then specify the query operators in the URL query parameters.</p>
<p>For example, the following request will return the first 10 rows of the customers dataset, sorted in ascending order by the last_name column:</p>
<pre><code class="language-bash">curl &quot;localhost:8080/api/tables/customers?sort=last_name&amp;limit=10&quot;
</code></pre>
<p>You can also use the filter parameter to specify a filter condition. For example, the following request will return all rows from the customers dataset where the first_name column is equal to John:</p>
<pre><code class="language-bash">curl &quot;localhost:8080/api/tables/customers?filter[first_name]=John&quot;
</code></pre>
<p>You can use the page and limit parameters to paginate the results. For example, the following request will return the second page of results, where each page contains 10 rows:</p>
<pre><code class="language-bash">curl &quot;localhost:8080/api/tables/customers?page=2&amp;limit=10&quot;
</code></pre>
<p>The <code>/api/tables/{table_name}</code> endpoint supports the following query parameters:</p>
<ol>
<li>
<p><code>columns</code>: specifies which columns of the dataset to include in the response.</p>
</li>
<li>
<p><code>sort</code>: specifies the order in which the rows of the dataset should be sorted. This parameter can be used to sort the rows in ascending or descending order by one or more columns.</p>
</li>
<li>
<p><code>limit</code>: specifies the maximum number of rows to include in the response.</p>
</li>
<li>
<p><code>filter</code>: specifies a condition that rows must satisfy in order to be included in the response.</p>
</li>
<li>
<p><code>page</code>: specifies which page of the dataset to include in the response, when pagination is used.
For example, to sort the rows of the dataset by the col1 and col2 columns in ascending and descending order, respectively, and return only the first 100 rows, the query might look like this:</p>
</li>
</ol>
<pre><code>/api/tables/{table_name}?sort=col1,-col2&amp;limit=100
</code></pre>
<p>To filter the rows of the dataset to only include those where the col1 column has the value foo, the query might look like this:</p>
<pre><code>/api/tables/{table_name}?filter[col1]=foo
</code></pre>
<p>And to retrieve the second page of the dataset, with 10 rows per page, the query might look like this:</p>
<pre><code>/api/tables/{table_name}?page=2&amp;limit=10
</code></pre>
<p>These query parameters can be combined in various ways to retrieve the desired subset of the dataset.</p>
<h3 id="sql"><a class="header" href="#sql">SQL</a></h3>
<p>To query a dataset using SQL in Ruspie, you can send a <code>POST</code> request to the <code>/api/sql</code> endpoint, and pass the SQL query in the request body as plain text.</p>
<p>For example, the following request will return the first 10 rows of the customers dataset, sorted in ascending order by the last_name column:</p>
<pre><code class="language-bash">curl -X POST -d &quot;SELECT * FROM customers ORDER BY last_name ASC LIMIT 10&quot; localhost:8080/api/sql
</code></pre>
<p>You can also use the WHERE clause in your SQL query to specify a filter condition. For example, the following request will return all rows from the customers dataset where the first_name column is equal to John:</p>
<pre><code class="language-bash">curl -X POST -d &quot;SELECT * FROM customers WHERE first_name = 'John'&quot; localhost:8080/api/sql
</code></pre>
<h3 id="graphql"><a class="header" href="#graphql">GRAPHQL</a></h3>
<p>To query a dataset using GraphQL in Ruspie, you can send a <code>POST</code> request to the <code>/api/graphql</code> endpoint, and pass the GraphQL query in the request body as plain text.</p>
<p>For example, the following request will return the first 10 rows of the customers dataset, sorted in ascending order by the last_name column:</p>
<pre><code class="language-bash">curl -X POST -d &quot;query { customers(sort: [{ field: &quot;last_name&quot;, order: &quot;asc&quot; }], limit: 10) { id,first_name,last_name } }&quot; localhost:8080/api/graphql
</code></pre>
<p>You can also use the filter parameter in your GraphQL query to specify a filter condition. For example, the following request will return all rows from the customers dataset where the first_name column is equal to John:</p>
<pre><code class="language-bash">curl -X POST -d &quot;query { customers(filter: { first_name: &quot;John&quot; }) { id,first_name,last_name } }&quot; localhost:8080/api/graphql
</code></pre>
<h3 id="note"><a class="header" href="#note">NOTE</a></h3>
<p>To override the <code>DEFAULT_EXT</code> use <code>FILE-EXT</code> header while querying. For example, to query a dataset in Parquet format, the <code>FILE-EXT</code> header have to be set to parquet:</p>
<pre><code class="language-bash">curl -H &quot;FILE-EXT: parquet&quot; localhost:8080/api/tables/{table_name}
</code></pre>
<h2 id="authorization"><a class="header" href="#authorization">AUTHORIZATION</a></h2>
<p>In Ruspie, authorization is enabled by setting the <code>MASTER_KEY</code> environment variable. Once this variable is set, users must provide a valid key in the <code>AUTHORIZATION</code> header of their request in order to access the Ruspie APIs.</p>
<p>Ruspie provides a set of endpoints for managing keys, which can be accessed by making a request to the <code>/auth/keys</code> endpoint. This endpoint supports the following methods:</p>
<ol>
<li><code>GET</code>: lists all keys that have been generated.</li>
<li><code>POST</code>: generates a new key.</li>
<li><code>PATCH</code> /{key_id}: edits the name and description of a key.</li>
<li><code>DELETE</code> /{key_id}: deletes a key.</li>
<li><code>POST</code> /invalidate/{key_id}: invalidates a key, rendering it no longer valid for authentication.</li>
</ol>
<p>To access these endpoints, users must provide the AUTHORIZATION header with their request, in the form <code>Bearer {MASTER_KEY}</code>, where <code>{MASTER_KEY}</code> is the value of the <code>MASTER_KEY</code> environment variable.</p>
<p>Once a key has been generated, it can be used to authenticate requests to the Ruspie APIs by providing it in the <code>AUTHORIZATION</code> header, in the form <code>Bearer {key}</code>, where <code>{key}</code> is the generated key. For example, to query the <code>/api/tables/{table_name}</code> endpoint with a generated key, the request might look like this:</p>
<pre><code class="language-bash">curl -H &quot;AUTHORIZATION: Bearer {key}&quot; localhost:8080/api/tables/{table_name}
</code></pre>
<p>Note that keys can be invalidated or deleted, in which case they will no longer be valid for authentication. Users should manage their keys carefully to ensure that only valid keys are used to access the Ruspie APIs.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ruspie-1"><a class="header" href="#ruspie-1">RUSPIE</a></h1>
<h2 id="introduction-1"><a class="header" href="#introduction-1">INTRODUCTION</a></h2>
<p>Ruspie is a query engine for datasets stored in CSV and Parquet formats. It allows you to query your data using SQL, REST API, and GraphQL. Ruspie is built on top of Apache Arrow and Datafusion, and it is written in Rust.</p>
<p>To use Ruspie, you can start the server by running the <code>cargo run</code> command, and specifying the path to your dataset files using the <code>FILE_PATH</code> environment variable. You can then send queries(SQL, GraphQL, REST Query params) to the server using the REST API. Ruspie supports a variety of query operators, such as filtering, sorting, and limiting the number of results, which can be specified in the query.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="quickstart-1"><a class="header" href="#quickstart-1">QUICKSTART</a></h2>
<p>To quickly setup Ruspie, follow these steps:</p>
<p>Install Rust, if you don't already have it installed. You can do this by following the instructions on the Rust website: <code>https://www.rust-lang.org/tools/install</code>.</p>
<p>Clone the Ruspie repository from GitHub: git clone <code>https://github.com/factly/ruspie.git</code></p>
<p>Navigate to the cloned repository and build the project using <code>cargo build</code></p>
<p>Set the <code>FILE_PATH</code> environment variable to the path of the dataset files that you want to serve through the API. For example: <code>FILE_PATH=./data</code></p>
<p>Start the Ruspie server by running <code>cargo run</code></p>
<p>You can now send queries to the Ruspie server using the REST API, SQL, or GraphQL. For more information, see the documentation for the project.</p>
<p>Note: If you want to enable token-based authorization, you will need to set the <code>MASTER_KEY</code> environment variable before starting the server. This will enable authentication for all the endpoints, and you will need to pass a valid authorization token in the <code>AUTHORIZATION</code> header of your requests.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="configuration-1"><a class="header" href="#configuration-1">CONFIGURATION</a></h2>
<p>You can configure Ruspie using environment variables. The following environment variables are available:</p>
<p><code>FILE_PATH</code>: This specifies the path to the dataset files that you want to serve through the API. If not set, the default is the test directory in the root of the project.</p>
<p><code>PORT</code>: This specifies the port that the Ruspie server will listen on. If not set, the default is 8080.</p>
<p><code>MASTER_KEY</code>: This enables token-based authorization for all endpoints. If not set, authentication is disabled.</p>
<p><code>LIMIT</code>: This specifies the default limit on the number of results returned by a query. If not set, the default is 100.</p>
<p><code>MAX_LIMIT</code>: This specifies the maximum limit that can be specified in a query. If not set, the default is 1000.</p>
<p><code>DEFAULT_EXT</code>: This specifies the default file extension that Ruspie will look for when serving files through the API. If not set, the default is csv.</p>
<p>To set an environment variable, you can use the export command before starting the Ruspie server. For example, to set the FILE_PATH variable to the data directory and the PORT variable to 8080, you can run the following commands:</p>
<pre><code class="language-bash">export FILE_PATH=./data
export PORT=8080
cargo run
</code></pre>
<p>You can also set the environment variables in your shell configuration file (e.g. .bashrc or .zshrc) so that they are automatically set when you open a new terminal. For more information, see the documentation for your shell.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="endpoints-1"><a class="header" href="#endpoints-1">ENDPOINTS</a></h2>
<p>Ruspie exposes the following endpoints:</p>
<ol>
<li>
<p><code>GET /api/tables/{table_name}</code>: This endpoint allows you to query a dataset using the REST query params. You can specify query operators such as filters, sorting, and limits in the URL query parameters.</p>
</li>
<li>
<p><code>POST /api/sql</code>: This endpoint allows you to query a dataset using SQL queries. You can pass the SQL query in the request body as plain text.</p>
</li>
<li>
<p><code>POST /api/graphql</code>: This endpoint allows you to query a dataset using GraphQL queries. You can pass the GraphQL query in the request body as plain text.</p>
</li>
<li>
<p><code>GET /api/schemas/{table_name}</code>: This endpoint returns the schema of the specified dataset.</p>
</li>
</ol>
<p>Note: If you have enabled token-based authorization, these endpoints will require a valid authorization token to be passed in the <code>AUTHORIZATION</code> header of the request.</p>
<p>Additionally, the following endpoints are available for managing API keys when token-based authorization is enabled:</p>
<ol>
<li>
<p><code>GET /auth/keys</code>: This endpoint allows you to list all the API keys that have been generated.</p>
</li>
<li>
<p><code>POST /auth/keys</code>: This endpoint allows you to generate a new API key.</p>
</li>
<li>
<p><code>PATCH /auth/keys/{key_id}</code>: This endpoint allows you to update the name and description of an existing API key.</p>
</li>
<li>
<p><code>DELETE /auth/keys/{key_id}</code>: This endpoint allows you to delete an existing API key.</p>
</li>
<li>
<p><code>POST /auth/keys/invalidate/{key_id}</code>: This endpoint allows you to invalidate an existing API key, preventing it from being used to access the API.</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="querying-1"><a class="header" href="#querying-1">Querying</a></h1>
<p>Ruspie Supports SQL, GraphQL, and querying with query params.</p>
<h3 id="note-1"><a class="header" href="#note-1">NOTE</a></h3>
<p>To override the <code>DEFAULT_EXT</code> use <code>FILE-EXT</code> header while querying. For example, to query a dataset in Parquet format, the <code>FILE-EXT</code> header have to be set to parquet:</p>
<pre><code class="language-bash">curl -H &quot;FILE-EXT: parquet&quot; localhost:8080/api/tables/{table_name}
curl -H &quot;FILE-EXT: parquet&quot; localhost:8080/api/sql
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="rest-1"><a class="header" href="#rest-1">REST</a></h3>
<p>To query a dataset using query parameters in Ruspie, you can send a <code>GET</code> request to the <code>/api/tables/{table_name}</code> endpoint, where <code>table_name</code> is the name of the dataset you want to query. You can then specify the query operators in the URL query parameters.</p>
<p>For example, the following request will return the first 10 rows of the customers dataset, sorted in ascending order by the last_name column:</p>
<pre><code class="language-bash">curl &quot;localhost:8080/api/tables/customers?sort=last_name&amp;limit=10&quot;
</code></pre>
<p>You can also use the filter parameter to specify a filter condition. For example, the following request will return all rows from the customers dataset where the first_name column is equal to John:</p>
<pre><code class="language-bash">curl &quot;localhost:8080/api/tables/customers?filter[first_name]=John&quot;
</code></pre>
<p>You can use the page and limit parameters to paginate the results. For example, the following request will return the second page of results, where each page contains 10 rows:</p>
<pre><code class="language-bash">curl &quot;localhost:8080/api/tables/customers?page=2&amp;limit=10&quot;
</code></pre>
<p>The <code>/api/tables/{table_name}</code> endpoint supports the following query parameters:</p>
<ol>
<li>
<p><code>columns</code>: specifies which columns of the dataset to include in the response.</p>
</li>
<li>
<p><code>sort</code>: specifies the order in which the rows of the dataset should be sorted. This parameter can be used to sort the rows in ascending or descending order by one or more columns.</p>
</li>
<li>
<p><code>limit</code>: specifies the maximum number of rows to include in the response.</p>
</li>
<li>
<p><code>filter</code>: specifies a condition that rows must satisfy in order to be included in the response.</p>
</li>
<li>
<p><code>page</code>: specifies which page of the dataset to include in the response, when pagination is used.
For example, to sort the rows of the dataset by the col1 and col2 columns in ascending and descending order, respectively, and return only the first 100 rows, the query might look like this:</p>
</li>
</ol>
<pre><code>/api/tables/{table_name}?sort=col1,-col2&amp;limit=100
</code></pre>
<p>To filter the rows of the dataset to only include those where the col1 column has the value foo, the query might look like this:</p>
<pre><code>/api/tables/{table_name}?filter[col1]=foo
</code></pre>
<p>And to retrieve the second page of the dataset, with 10 rows per page, the query might look like this:</p>
<pre><code>/api/tables/{table_name}?page=2&amp;limit=10
</code></pre>
<p>These query parameters can be combined in various ways to retrieve the desired subset of the dataset.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="sql-1"><a class="header" href="#sql-1">SQL</a></h3>
<p>To query a dataset using SQL in Ruspie, you can send a <code>POST</code> request to the <code>/api/sql</code> endpoint, and pass the SQL query in the request body as plain text.</p>
<p>For example, the following request will return the first 10 rows of the customers dataset, sorted in ascending order by the last_name column:</p>
<pre><code class="language-bash">curl -X POST -d &quot;SELECT * FROM customers ORDER BY last_name ASC LIMIT 10&quot; localhost:8080/api/sql
</code></pre>
<p>You can also use the WHERE clause in your SQL query to specify a filter condition. For example, the following request will return all rows from the customers dataset where the first_name column is equal to John:</p>
<pre><code class="language-bash">curl -X POST -d &quot;SELECT * FROM customers WHERE first_name = 'John'&quot; localhost:8080/api/sql
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="graphql-1"><a class="header" href="#graphql-1">GRAPHQL</a></h3>
<p>To query a dataset using GraphQL in Ruspie, you can send a <code>POST</code> request to the <code>/api/graphql</code> endpoint, and pass the GraphQL query in the request body as plain text.</p>
<p>For example, the following request will return the first 10 rows of the customers dataset, sorted in ascending order by the last_name column:</p>
<pre><code class="language-bash">curl -X POST -d &quot;query { customers(sort: [{ field: &quot;last_name&quot;, order: &quot;asc&quot; }], limit: 10) { id,first_name,last_name } }&quot; localhost:8080/api/graphql
</code></pre>
<p>You can also use the filter parameter in your GraphQL query to specify a filter condition. For example, the following request will return all rows from the customers dataset where the first_name column is equal to John:</p>
<pre><code class="language-bash">curl -X POST -d &quot;query { customers(filter: { first_name: &quot;John&quot; }) { id,first_name,last_name } }&quot; localhost:8080/api/graphql
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="authorization-1"><a class="header" href="#authorization-1">Authorization</a></h2>
<p>In Ruspie, authorization is enabled by setting the <code>MASTER_KEY</code> environment variable. Once this variable is set, users must provide a valid key in the <code>AUTHORIZATION</code> header of their request in order to access the Ruspie APIs.</p>
<p>Ruspie provides a set of endpoints for managing keys, which can be accessed by making a request to the <code>/auth/keys</code> endpoint. This endpoint supports the following methods:</p>
<ol>
<li><code>GET</code>: lists all keys that have been generated.</li>
<li><code>POST</code>: generates a new key.</li>
<li><code>PATCH</code> /{key_id}: edits the name and description of a key.</li>
<li><code>DELETE</code> /{key_id}: deletes a key.</li>
<li><code>POST</code> /invalidate/{key_id}: invalidates a key, rendering it no longer valid for authentication.</li>
</ol>
<p>To access these endpoints, users must provide the AUTHORIZATION header with their request, in the form <code>Bearer {MASTER_KEY}</code>, where <code>{MASTER_KEY}</code> is the value of the <code>MASTER_KEY</code> environment variable.</p>
<p>Once a key has been generated, it can be used to authenticate requests to the Ruspie APIs by providing it in the <code>AUTHORIZATION</code> header, in the form <code>Bearer {key}</code>, where <code>{key}</code> is the generated key. For example, to query the <code>/api/tables/{table_name}</code> endpoint with a generated key, the request might look like this:</p>
<pre><code class="language-bash">curl -H &quot;AUTHORIZATION: Bearer {key}&quot; localhost:8080/api/tables/{table_name}
</code></pre>
<p>Note that keys can be invalidated or deleted, in which case they will no longer be valid for authentication. Users should manage their keys carefully to ensure that only valid keys are used to access the Ruspie APIs.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
